% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculate_age.R
\name{calculate_age_end}
\alias{calculate_age_end}
\title{Calculates the end of each age group given a series of start values for each age group}
\usage{
calculate_age_end(dt, id_cols, terminal_age_end = 125L)
}
\arguments{
\item{dt}{data.table with age-specific data.
\itemize{
\item must contain columns specified in \code{id_cols}.
\item must include a numeric column called 'age_start' that contains no missing
values.
\item each combination of \code{id_cols} must uniquely identify each row.
}}

\item{id_cols}{character vector of id columns that uniquely identify each row
of \code{dt}.
\itemize{
\item must include 'age_start'.
}}

\item{terminal_age_end}{the numeric 'age_end' value for the terminal age
group.}
}
\value{
modifies \code{dt} in place by creating a new numeric column called
'age_end'.
}
\description{
Creates a new column in the input data.table called 'age_end'.
}
\details{
'age_start' is inclusive while 'age_end' exclusive. So for example age group
\eqn{a} with 'age_start' equal to 5 and 'age_end' equal to 10 spans
\eqn{5 <= a < 10}.

This function assumes that only the most detailed age groups are in the input
dataset.
}
\examples{
input_dt <- data.table::data.table(location = "France", year = 2010,
                                   sex = "female",
                                   age_start = 0:95,
                                   value1 = 1, value2 = 2)
id_cols <- c("location", "year", "sex", "age_start")
value_cols <- c("value1", "value2")
calculate_age_end(input_dt, id_cols, terminal_age_end = 125)
}
