% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agg_scale.R
\name{agg}
\alias{agg}
\alias{scale}
\title{Aggregate/Scale a detailed level of a variable to an aggregate level}
\usage{
agg(
  dt,
  id_cols,
  value_cols,
  col_stem,
  col_type,
  mapping,
  agg_function = sum,
  missing_dt_severity = "stop",
  drop_present_aggs = FALSE
)

scale(
  dt,
  id_cols,
  value_cols,
  col_stem,
  col_type,
  mapping = NULL,
  agg_function = sum,
  missing_dt_severity = "stop",
  collapse_missing = FALSE
)
}
\arguments{
\item{dt}{[\code{data.table()}]\cr
Data to be aggregated or scaled.}

\item{id_cols}{[\code{character()}]\cr
ID columns that uniquely identify each row of \code{dt}.}

\item{value_cols}{[\code{character()}]\cr
Value columns that should be aggregated.}

\item{col_stem}{[\code{character(1)}]\cr
The name of the variable to be aggregated or scaled over. If aggregating an
'interval' variable should not include the '_start' or '_end' suffix.}

\item{col_type}{[\code{character(1)}]\cr
The type of variable that is being aggregated or scaled over. Can be either
'categorical' or 'interval'.}

\item{mapping}{[\code{data.table()}]\cr
For 'categorical' variables, defines how different levels of the variable
relate to each other. For aggregating 'interval' variables, it is used to
specify intervals to aggregate to, while when scaling the mapping is
inferred from the available intervals in \code{dt}.}

\item{agg_function}{[\verb{function()}]\cr
Function to use when aggregating, can be either \code{sum} (for counts) or
\code{prod} (for probabilities).}

\item{missing_dt_severity}{[\code{character(1)}]\cr
How severe should the consequences of missing data that prevents
aggregation or scaling from occurring be? Can be either "stop", "warning",
"message", or "none". If not "stop", then only the possible aggregations or
scaling is done using the available data.}

\item{drop_present_aggs}{[\code{logical(1)}]\cr
Whether to drop aggregates (or overlapping intervals) that are already
present in \code{dt} before aggregating. Default is "False" and the function
errors out.}

\item{collapse_missing}{[\code{logical(1)}]\cr
When scaling \code{categorical} data, whether to collapse missing intermediate
levels in \code{mapping}. Default is "False" and the function errors out due to
missing data.}
}
\value{
[\code{data.table()}] with \code{id_cols} and \code{value_cols} columns for
requested aggregates or with scaled values.
}
\description{
Aggregate counts or probabilities from a detailed level of a
variable to an aggregate level or scale the detailed level values so that the
detailed level aggregated together equals the aggregate level.
}
\details{
The \code{agg} function can be used to aggregate over a 'categorical' variable
like location, from the country level to global level or over an 'interval'
variable like age from five year age-groups to all-ages combined.

The \code{scale} function can be used to scale over a 'categorical' variable
like location, so that the sub-national level aggregated together equals the
national level. Similarly can be used to scale over an 'interval' variable
like age so that the five year age groups aggregated together equals the
all-ages value.

If 'location' is the variable to be aggregated or scaled then
\code{col_stem = 'location'} and "location" must be included in \code{id_cols.} If
'age' is the variable to be aggregated or scaled then \code{col_stem = 'age'} and
'age_start' and 'age_end' must be included in \code{id_cols} since both variables
are needed to represent interval variables.

The \code{mapping} argument for categorical variables must have columns called
'parent' and 'child' that represent how each possible variable relates to
each other. For example if aggregating or scaling locations then mapping
needs to define how each child location relates to each parent location. It
is then assumed that each node in the \code{mapping} hierarchy will need to be
aggregated to.

For numeric interval variables the \code{mapping} argument must have columns for
\verb{\{col_stem\}_start} and \verb{\{col_stem\}_end} defining the start and end of each
aggregate interval.

These functions work even if \code{dt} is not a square dataset. Meaning it is okay
if different combinations of \code{id_vars} have different \code{col_stem} values. For
example if making age aggregates, it is okay if some location-years have
5-year age groups while other location-years have 1-year age groups.
}
\examples{
# aggregate count data from present day Iran provinces to historical
# provinces and Iran as a whole
input_dt <- data.table::CJ(location = iran_mapping[!grepl("[0-9]+", child),
                                                   child],
                           year = 2011,
                           value = 1)
output_dt <- agg(dt = input_dt,
                 id_cols = c("location", "year"),
                 value_cols = "value",
                 col_stem = "location",
                 col_type = "categorical",
                 mapping = iran_mapping)

# scale count data from present day Iran provinces to Iran national value
input_dt <- data.table::CJ(location = iran_mapping[!grepl("[0-9]+", child),
                                                   child],
                           year = 2011,
                           value = 1)
input_dt_agg <- data.table::data.table(
  location = "Iran (Islamic Republic of)",
  year = 2011, value = 62
)
input_dt <- rbind(input_dt, input_dt_agg)
output_dt <- scale(dt = input_dt,
                   id_cols = c("location", "year"),
                   value_cols = "value",
                   col_stem = "location",
                   col_type = "categorical",
                   mapping = iran_mapping,
                   collapse_missing = TRUE)

# aggregate age-specific count data
input_dt <- data.table::data.table(year = 2010,
                        age_start = seq(0, 95, 1),
                        value1 = 1, value2 = 2)
gen_end(input_dt, id_cols = c("year", "age_start"), col_stem = "age")
age_mapping <- data.table::data.table(age_start = c(0, 15, 85),
                                      age_end = c(5, 60, Inf))
output_dt <- agg(dt = input_dt,
                 id_cols = c("year", "age_start", "age_end"),
                 value_cols = c("value1", "value2"),
                 col_stem = "age",
                 col_type = "interval",
                 mapping = age_mapping)

# scale age-specific probability data

}
