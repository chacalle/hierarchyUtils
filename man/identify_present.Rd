% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agg_scale.R
\name{identify_present_agg_dt}
\alias{identify_present_agg_dt}
\alias{identify_present_scale_dt}
\title{Identify aggregates rows in dataset that are already present.}
\usage{
identify_present_agg_dt(
  dt,
  id_cols,
  value_cols,
  col_stem,
  col_type,
  mapping,
  agg_function = sum
)

identify_present_scale_dt(
  dt,
  id_cols,
  value_cols,
  col_stem,
  col_type,
  mapping,
  agg_function = sum,
  collapse_missing
)
}
\arguments{
\item{dt}{[\code{data.table()}]\cr
Data to be aggregated or scaled.}

\item{id_cols}{[\code{character()}]\cr
ID columns that uniquely identify each row of \code{dt}.}

\item{value_cols}{[\code{character()}]\cr
Value columns that should be aggregated.}

\item{col_stem}{[\code{character(1)}]\cr
The name of the variable to be aggregated or scaled over. If aggregating an
'interval' variable should not include the '_start' or '_end' suffix.}

\item{col_type}{[\code{character(1)}]\cr
The type of variable that is being aggregated or scaled over. Can be either
'categorical' or 'interval'.}

\item{mapping}{[\code{data.table()}]\cr
For 'categorical' variables, defines how different levels of the variable
relate to each other. For aggregating 'interval' variables, it is used to
specify intervals to aggregate to, while when scaling the mapping is
inferred from the available intervals in \code{dt}.}

\item{agg_function}{[\verb{function()}]\cr
Function to use when aggregating, can be either \code{sum} (for counts) or
\code{prod} (for probabilities).}

\item{collapse_missing}{[\code{logical(1)}]\cr
When scaling \code{categorical} data, whether to collapse missing intermediate
levels in \code{mapping}. Default is "False" and the function errors out due to
missing data.}
}
\value{
[\code{data.table()}] aggregate rows in \code{dt} that are already present.
}
\description{
Identify aggregates rows in dataset that are already present.
}
\examples{
# TODO add examples

}
